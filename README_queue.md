# Простейшая реализация многопоточной очереди
Для реализации простейшей многопоточной очереди "заказчик-исполнитель" на C++ можно использовать стандартную библиотеку `<thread>`, `<mutex>`, `<condition_variable>` и `<queue>`. В этой модели один или несколько потоков-заказчиков добавляют задачи в очередь, а один или несколько потоков-исполнителей извлекают задачи из очереди и выполняют их.

Вот пример простейшей реализации:
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <functional>
#include <chrono>

class ThreadSafeQueue {
public:
    void push(std::function<void()> task) {
        std::unique_lock<std::mutex> lock(mutex_);
        queue_.push(task);
        lock.unlock();
        condition_.notify_one();
    }

    std::function<void()> pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this]() { return !queue_.empty(); });
        auto task = queue_.front();
        queue_.pop();
        return task;
    }

private:
    std::queue<std::function<void()>> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;
};

void producer(ThreadSafeQueue& queue, int id) {
    for (int i = 0; i < 5; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Имитация работы
        queue.push([id, i]() {
            std::cout << "Задача " << i << " от заказчика " << id << " выполняется\n";
        });
    }
}

void consumer(ThreadSafeQueue& queue, int id) {
    while (true) {
        auto task = queue.pop();
        task();
    }
}

int main() {
    ThreadSafeQueue queue;

    // Создаем заказчиков
    std::thread producer1(producer, std::ref(queue), 1);
    std::thread producer2(producer, std::ref(queue), 2);

    // Создаем исполнителей
    std::thread consumer1(consumer, std::ref(queue), 1);
    std::thread consumer2(consumer, std::ref(queue), 2);

    producer1.join();
    producer2.join();

    // Ожидаем завершения работы заказчиков
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Завершаем работу исполнителей (в реальном приложении нужно предусмотреть корректное завершение)
    consumer1.detach();
    consumer2.detach();

    return 0;
}
```

## Описание:
**ThreadSafeQueue**: Это потокобезопасная очередь, которая использует мьютекс и условную переменную для синхронизации доступа к очереди задач. Метод push добавляет задачу в очередь, а метод pop извлекает задачу из очереди, блокируя поток, если очередь пуста.

**producer**: Это функция, которая имитирует работу заказчика. Она добавляет задачи в очередь с небольшой задержкой.

**consumer**: Это функция, которая имитирует работу исполнителя. Она извлекает задачи из очереди и выполняет их.

**main**: В главной функции создаются потоки-заказчики и потоки-исполнители. После завершения работы заказчиков, программа ждет некоторое время, чтобы исполнители успели обработать все задачи, а затем завершает работу.

**Примечания**:
В реальном приложении нужно предусмотреть механизм корректного завершения работы исполнителей, например, с использованием флага завершения или специальной задачи, которая сигнализирует о завершении работы.

В данном примере используется detach для потоков-исполнителей, что не является лучшей практикой, но используется для упрощения примера. В реальном приложении лучше использовать join и корректно завершать потоки.

Этот пример демонстрирует базовую концепцию многопоточной очереди "заказчик-исполнитель" и может быть расширен в зависимости от требований конкретного приложения.

## Устройство класса
Класс ThreadSafeQueue в примере реализует потокобезопасную очередь задач. Это означает, что несколько потоков могут одновременно добавлять задачи в очередь и извлекать их оттуда без возникновения состояний гонки (race conditions). 

## Основные компоненты класса 
**Очередь задач** (`std::queue<std::function<void()>> queue_`):

Это обычная очередь, которая хранит задачи в виде `std::function<void()>`. Каждая задача — это функция, которую нужно выполнить.

`std::function<void()>` — это обертка для любой вызываемой сущности (функции, лямбды, функтора), которая не принимает аргументов и не возвращает значений.

**Мьютекс** (`std::mutex mutex_`):

Мьютекс используется для синхронизации доступа к очереди. Он гарантирует, что только один поток может одновременно изменять очередь (добавлять или извлекать задачи).

Без мьютекса несколько потоков могли бы одновременно пытаться изменить очередь, что привело бы к неопределенному поведению.

**Условная переменная** (`std::condition_variable condition_`):

Условная переменная используется для уведомления потоков-исполнителей о том, что в очереди появилась новая задача.

Она позволяет потокам-исполнителям "спать" (блокироваться), пока очередь пуста, и "просыпаться", когда в очереди появляется задача.

## Методы класса
1. `void push(std::function<void()> task)`
Этот метод добавляет задачу в очередь.
```cpp
void push(std::function<void()> task) {
    std::unique_lock<std::mutex> lock(mutex_); // Захватываем мьютекс
    queue_.push(task); // Добавляем задачу в очередь
    lock.unlock(); // Освобождаем мьютекс
    condition_.notify_one(); // Уведомляем один из ожидающих потоков
}
```
- `std::unique_lock<std::mutex> lock(mutex_)`:

    - Захватывает мьютекс, чтобы обеспечить эксклюзивный доступ к очереди.

    - `std::unique_lock` — это RAII-обертка для мьютекса, которая автоматически освобождает мьютекс при выходе из области видимости.

- `queue_.push(task)`:

    - Добавляет задачу в очередь.

- `lock.unlock()`:

    - Освобождает мьютекс вручную, чтобы уменьшить время удержания мьютекса. Это позволяет другим потокам быстрее получить доступ к очереди.

- `condition_.notify_one()`:

    - Уведомляет один из потоков, ожидающих на условной переменной, что в очереди появилась новая задача.

