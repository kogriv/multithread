# Простейшая реализация многопоточной очереди
Для реализации простейшей многопоточной очереди "заказчик-исполнитель" на C++ можно использовать стандартную библиотеку `<thread>`, `<mutex>`, `<condition_variable>` и `<queue>`. В этой модели один или несколько потоков-заказчиков добавляют задачи в очередь, а один или несколько потоков-исполнителей извлекают задачи из очереди и выполняют их.

Вот пример простейшей реализации:
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <functional>
#include <chrono>

class ThreadSafeQueue {
public:
    void push(std::function<void()> task) {
        std::unique_lock<std::mutex> lock(mutex_);
        queue_.push(task);
        lock.unlock();
        condition_.notify_one();
    }

    std::function<void()> pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this]() { return !queue_.empty(); });
        auto task = queue_.front();
        queue_.pop();
        return task;
    }

private:
    std::queue<std::function<void()>> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;
};

void producer(ThreadSafeQueue& queue, int id) {
    for (int i = 0; i < 5; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Имитация работы
        queue.push([id, i]() {
            std::cout << "Задача " << i << " от заказчика " << id << " выполняется\n";
        });
    }
}

void consumer(ThreadSafeQueue& queue, int id) {
    while (true) {
        auto task = queue.pop();
        task();
    }
}

int main() {
    ThreadSafeQueue queue;

    // Создаем заказчиков
    std::thread producer1(producer, std::ref(queue), 1);
    std::thread producer2(producer, std::ref(queue), 2);

    // Создаем исполнителей
    std::thread consumer1(consumer, std::ref(queue), 1);
    std::thread consumer2(consumer, std::ref(queue), 2);

    producer1.join();
    producer2.join();

    // Ожидаем завершения работы заказчиков
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Завершаем работу исполнителей (в реальном приложении нужно предусмотреть корректное завершение)
    consumer1.detach();
    consumer2.detach();

    return 0;
}
```

## Описание:
**ThreadSafeQueue**: Это потокобезопасная очередь, которая использует мьютекс и условную переменную для синхронизации доступа к очереди задач. Метод push добавляет задачу в очередь, а метод pop извлекает задачу из очереди, блокируя поток, если очередь пуста.

**producer**: Это функция, которая имитирует работу заказчика. Она добавляет задачи в очередь с небольшой задержкой.

**consumer**: Это функция, которая имитирует работу исполнителя. Она извлекает задачи из очереди и выполняет их.

**main**: В главной функции создаются потоки-заказчики и потоки-исполнители. После завершения работы заказчиков, программа ждет некоторое время, чтобы исполнители успели обработать все задачи, а затем завершает работу.

**Примечания**:
В реальном приложении нужно предусмотреть механизм корректного завершения работы исполнителей, например, с использованием флага завершения или специальной задачи, которая сигнализирует о завершении работы.

В данном примере используется detach для потоков-исполнителей, что не является лучшей практикой, но используется для упрощения примера. В реальном приложении лучше использовать join и корректно завершать потоки.

Этот пример демонстрирует базовую концепцию многопоточной очереди "заказчик-исполнитель" и может быть расширен в зависимости от требований конкретного приложения.

## Устройство класса
Класс ThreadSafeQueue в примере реализует потокобезопасную очередь задач. Это означает, что несколько потоков могут одновременно добавлять задачи в очередь и извлекать их оттуда без возникновения состояний гонки (race conditions). 

## Основные компоненты класса 
**Очередь задач** (`std::queue<std::function<void()>> queue_`):

    - Это обычная очередь, которая хранит задачи в виде `std::function<void()>`. Каждая задача — это функция, которую нужно выполнить.

    - `std::function<void()>` — это обертка для любой вызываемой сущности (функции, лямбды, функтора), которая не принимает аргументов и не возвращает значений.

**Мьютекс** (`std::mutex mutex_`):

    - Мьютекс используется для синхронизации доступа к очереди. Он гарантирует, что только один поток может одновременно изменять очередь (добавлять или извлекать задачи).

    - Без мьютекса несколько потоков могли бы одновременно пытаться изменить очередь, что привело бы к неопределенному поведению.

**Условная переменная** (`std::condition_variable condition_`):

    - Условная переменная используется для уведомления потоков-исполнителей о том, что в очереди появилась новая задача.

    - Она позволяет потокам-исполнителям "спать" (блокироваться), пока очередь пуста, и "просыпаться", когда в очереди появляется задача.

## Методы класса
1. `void push(std::function<void()> task)`
Этот метод добавляет задачу в очередь.
```cpp
void push(std::function<void()> task) {
    std::unique_lock<std::mutex> lock(mutex_); // Захватываем мьютекс
    queue_.push(task); // Добавляем задачу в очередь
    lock.unlock(); // Освобождаем мьютекс
    condition_.notify_one(); // Уведомляем один из ожидающих потоков
}
```
- `std::unique_lock<std::mutex> lock(mutex_)`:

    - Захватывает мьютекс, чтобы обеспечить эксклюзивный доступ к очереди.

    - `std::unique_lock` — это RAII-обертка для мьютекса, которая автоматически освобождает мьютекс при выходе из области видимости.

- `queue_.push(task)`:

    - Добавляет задачу в очередь.

- `lock.unlock()`:

    - Освобождает мьютекс вручную, чтобы уменьшить время удержания мьютекса. Это позволяет другим потокам быстрее получить доступ к очереди.

- `condition_.notify_one()`:

    - Уведомляет один из потоков, ожидающих на условной переменной, что в очереди появилась новая задача.

2. `std::function<void()> pop()`
Этот метод извлекает задачу из очереди. Если очередь пуста, поток блокируется до тех пор, пока не появится новая задача.
```cpp
std::function<void()> pop() {
    std::unique_lock<std::mutex> lock(mutex_); // Захватываем мьютекс
    condition_.wait(lock, [this]() { return !queue_.empty(); }); // Ждем, пока очередь не станет непустой
    auto task = queue_.front(); // Берем задачу из очереди
    queue_.pop(); // Удаляем задачу из очереди
    return task; // Возвращаем задачу
}
```
- `std::unique_lock<std::mutex> lock(mutex_)`:

    - Захватывает мьютекс для обеспечения эксклюзивного доступа к очереди.

- `condition_.wait(lock, [this]() { return !queue_.empty(); })`:

    - Условная переменная `condition_` блокирует текущий поток до тех пор, пока не выполнится условие `!queue_.empty()` (очередь не пуста).

    - Второй аргумент `wait` — это предикат (лямбда-функция), который проверяет, выполнено ли условие.

    - Если очередь пуста, поток освобождает мьютекс и переходит в состояние ожидания. Когда другой поток вызовет `notify_one()` или `notify_all()`, поток "проснется" и снова проверит условие.

- `auto task = queue_.front()`:

    - Извлекает задачу из начала очереди.

- `queue_.pop()`:

    - Удаляет задачу из очереди.

- `return task`:

    - Возвращает задачу для выполнения.

## Синтаксис push и pop
Методы push и pop выполняют разные задачи, поэтому их объявления отличаются: 

`push`:  
Его задача — добавить элемент в очередь.  
Он принимает задачу в качестве аргумента, но ничего не возвращает.  
Поэтому его объявление выглядит как `void push(std::function<void()> task)`.

`pop`:  
Его задача — извлечь элемент из очереди.  
Он не принимает аргументов, но возвращает задачу. 
Поэтому его объявление выглядит как `std::function<void()> pop()`.

**Аналогия**  
Представьте, что очередь — это почтовый ящик:  
`push`:  
Это как положить письмо в ящик. Вы передаете письмо (задачу) в метод, но ничего не получаете взамен.
Синтаксис: `void push(письмо)`.  
`pop`:  
Это как достать письмо из ящика. Вы не передаете ничего в метод, но получаете письмо (задачу) в ответ. 
Синтаксис: `письмо pop()`.

## Как работает синхронизация
1. Добавление задачи:

    - Когда поток-заказчик вызывает `push`, он захватывает мьютекс, добавляет задачу в очередь, освобождает мьютекс и уведомляет один из потоков-исполнителей через `condition_.notify_one()`.

2. Извлечение задачи:

    - Когда поток-исполнитель вызывает `pop`, он захватывает мьютекс и проверяет, есть ли задачи в очереди.

    - Если очередь пуста, поток блокируется на условной переменной `condition_`, освобождая мьютекс.

    - Когда поток-заказчик добавляет задачу и вызывает `notify_one()`, поток-исполнитель "просыпается", снова захватывает мьютекс и проверяет условие. Если очередь не пуста, он извлекает задачу.

## Почему это безопасно?
Мьютекс гарантирует, что только один поток может одновременно изменять очередь.

Условная переменная позволяет потокам-исполнителям эффективно ждать появления задач, не занимая процессорное время (это называется "ожиданием с блокировкой").

Использование `std::unique_lock` обеспечивает безопасное управление мьютексом, даже если произойдет исключение.

# что такое `std::function<void()>`
## описание `std::function<void()>`
`std::function<void()>` — это шаблонный класс из стандартной библиотеки C++ (заголовочный файл `<functional>`), который представляет собой универсальную обертку для любой вызываемой сущности. Это может быть:

- Обычная функция.

- Лямбда-выражение.

- Функтор (объект класса с перегруженным оператором ()).

- Указатель на метод класса.

В данном случае `std::function<void()>` означает:

`void` — вызываемая сущность не возвращает никакого значения.

`()` — вызываемая сущность не принимает никаких аргументов.

Таким образом, `std::function<void()>` — это обертка для любой функции, лямбды или функтора, которая не принимает аргументов и не возвращает значений.

## Зачем это нужно?
`std::function` используется для того, чтобы:

- Унифицировать хранение и вызов разных типов вызываемых сущностей.

- Вместо того чтобы писать отдельные обработчики для функций, лямбд и функторов, можно использовать `std::function` для работы с ними единообразно.

- Передавать вызываемые сущности в качестве аргументов или возвращать их из функций.

    - Например, в многопоточных очередях задачи часто представляются как `std::function<void()>`, чтобы можно было передавать любые задачи в очередь.

- Хранить вызываемые сущности в контейнерах.

    - Например, можно создать `std::vector<std::function<void()>>` для хранения списка задач.

## Примеры использования `std::function<void()>`
1. Обычная функция
```cpp
#include <iostream>
#include <functional> // Для std::function

void hello() {
    std::cout << "Hello, World!\n";
}

int main() {
    std::function<void()> task = hello; // Обернули функцию hello
    task(); // Вызов функции через std::function
    return 0;
}
```
2. Лямбда-выражение
```cpp
#include <iostream>
#include <functional>

int main() {
    std::function<void()> task = []() {
        std::cout << "Это лямбда!\n";
    };
    task(); // Вызов лямбды через std::function
    return 0;
}
```

3. Функтор (объект с перегруженным оператором ())
```cpp
#include <iostream>
#include <functional>

class Greeter {
public:
    void operator()() const {
        std::cout << "Привет из функтора!\n";
    }
};

int main() {
    Greeter greeter;
    std::function<void()> task = greeter; // Обернули функтор
    task(); // Вызов функтора через std::function
    return 0;
}
```
4. Указатель на метод класса
```cpp
#include <iostream>
#include <functional>

class MyClass {
public:
    void print() const {
        std::cout << "Метод класса!\n";
    }
};

int main() {
    MyClass obj;
    std::function<void()> task = std::bind(&MyClass::print, &obj); // Обернули метод класса
    task(); // Вызов метода через std::function
    return 0;
}
```
## Как это работает внутри?
`std::function` использует механизм type erasure (стирание типа), чтобы хранить и вызывать любые вызываемые сущности. Это означает:

Внутри `std::function` хранится указатель на базовый класс, который знает, как вызывать обернутую сущность.

Для каждой конкретной сущности (функции, лямбды, функтора) создается производный класс, который реализует вызов.

Когда вы вызываете `std::function`, он делегирует вызов этой сущности через виртуальную таблицу.

## Почему `std::function<void()>` используется в многопоточных очередях?
В многопоточных очередях задачи могут быть представлены разными способами: функциями, лямбдами, функторами. `std::function<void()>` позволяет:

Унифицировать хранение задач в очереди.

Передавать задачи между потоками.

Вызывать задачи в потоке-исполнителе, не зная их конкретного типа.

# ref в инструкции std::thread producer1(producer, std::ref(queue), 1)
`std::ref(queue)` используется для передачи объекта queue по ссылке в функцию producer.

## Зачем нужно `std::ref`?  
По умолчанию, когда вы передаете аргументы в функцию через `std::thread`, они передаются по значению. Это означает, что `std::thread` создает копии всех аргументов и передает их в функцию. Однако, если вы хотите передать объект по ссылке (чтобы избежать копирования и работать с оригинальным объектом), нужно явно указать это с помощью `std::ref`.

В данном случае:

`queue` — это объект типа `ThreadSafeQueue`, который находится в `main`.

Мы хотим, чтобы функция `producer` работала с оригинальным объектом `queue`, а не с его копией.

Если бы мы не использовали `std::ref`, то `std::thread` создал бы копию queue, и функция producer работала бы с этой копией, а не с оригинальным объектом. Это привело бы к некорректной работе программы, так как изменения в копии не отражались бы на оригинальном объекте.

## Как работает std::ref?
`std::ref` — это функция из стандартной библиотеки C++ (заголовочный файл `<functional>`), которая возвращает объект типа `std::reference_wrapper`. Этот объект имитирует ссылку и может быть использован для передачи объектов по ссылке в места, где ожидается передача по значению (например, в `std::thread`).

Пример:
```cpp
#include <iostream>
#include <functional> // для std::ref

void modify(int& x) {
    x = 42;
}

int main() {
    int value = 10;
    std::cout << "До вызова: " << value << "\n"; // 10

    // Передаем value по ссылке с помощью std::ref
    modify(std::ref(value));

    std::cout << "После вызова: " << value << "\n"; // 42
    return 0;
}
```
Вывод:
```bash
До вызова: 10
После вызова: 42
```

## Без std::ref
```cpp
std::thread producer1(producer, queue, 1); // Ошибка: queue передается по значению
```
Компилятор выдаст ошибку, так как queue нельзя скопировать (потому что `std::mutex` и `std::condition_variable` внутри `ThreadSafeQueue` не могут быть скопированы).

# Lambda

Функция producer имитирует работу заказчика, который добавляет задачи в очередь queue. Вот код функции:
```cpp
void producer(ThreadSafeQueue& queue, int id) {
    for (int i = 0; i < 5; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Имитация работы
        queue.push([id, i]() {
            std::cout << "Задача " << i << " от заказчика " << id << " выполняется\n";
        });
    }
}
```
Синтаксис `queue.push`  
Здесь используется лямбда-выражение для создания задачи.  
1. Лямбда-выражение  
**Лямбда-выражение** — это анонимная функция, которая может быть определена прямо в месте использования. Синтаксис лямбда-выражения в C++ выглядит так:
```cpp
[захват](параметры) { тело_функции }
```
- **[захват]** — список переменных, которые лямбда захватывает из окружающей области видимости.

- **(параметры)** — список параметров функции (может быть пустым).

- **{ тело_функции }** — код, который выполняется при вызове лямбды.

2. Захват переменных `[id, i]`  
В данном случае `[id, i]` — это список захвата. Он указывает, какие переменные из окружающей области видимости должны быть доступны внутри лямбды.

`id` — идентификатор заказчика.

`i` — текущий номер задачи.

Захват по значению (`[id, i]`) означает, что лямбда создает копии этих переменных и использует их внутри своего тела.

3. Пустые круглые скобки `()`  
Круглые скобки `()` после списка захвата указывают на то, что лямбда не принимает никаких параметров. Это сигнатура функции.

4. Тело лямбды  
Тело лямбды — это код, который выполняется при вызове задачи:
```cpp
{
    std::cout << "Задача " << i << " от заказчика " << id << " выполняется\n";
}
```
5. Передача лямбды в `queue.push`  
Лямбда-выражение передается в метод `queue.push`. Поскольку queue — это `ThreadSafeQueue`, а `push` принимает `std::function<void()>`, лямбда автоматически преобразуется в объект `std::function<void()>`.

## Полный разбор строки
- `[id, i]`:

    - Лямбда захватывает переменные id и i по значению.

- `()`:

    - Лямбда не принимает параметров.

- `{ тело }`:

    - Лямбда выводит сообщение в консоль, используя захваченные переменные.

- `queue.push`:

    - Лямбда передается в очередь как задача типа `std::function<void()>`.

## Лямбда с параметрами
Если лямбда-выражение должно принимать параметры, то круглые скобки `()` не будут пустыми — в них нужно указать параметры, которые лямбда будет принимать. Однако, в контексте `queue.push`, где задачи хранятся как `std::function<void()>`, лямбда не может принимать параметры, потому что `std::function<void()>` ожидает функцию без аргументов.

Тем не менее, если мы хотим, чтобы лямбда принимала параметры, нам нужно изменить тип очереди или использовать дополнительные механизмы для передачи параметров. 

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <functional>
#include <mutex>
#include <condition_variable>

class ThreadSafeQueue {
public:
    void push(std::function<void(int)> task) {
        std::unique_lock<std::mutex> lock(mutex_);
        queue_.push(task);
        lock.unlock();
        condition_.notify_one();
    }

    std::function<void(int)> pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this]() { return !queue_.empty(); });
        auto task = queue_.front();
        queue_.pop();
        return task;
    }

private:
    std::queue<std::function<void(int)>> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;
};

void producer(ThreadSafeQueue& queue, int id) {
    for (int i = 0; i < 5; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Имитация работы
        queue.push([id, i](int additionalParam) {
            std::cout << "Задача " << i << " от заказчика " << id 
                      << " с параметром " << additionalParam << " выполняется\n";
        });
    }
}

void consumer(ThreadSafeQueue& queue, int id) {
    while (true) {
        auto task = queue.pop();
        task(42); // Передаем параметр в лямбду
    }
}

int main() {
    ThreadSafeQueue queue;

    std::thread producer1(producer, std::ref(queue), 1);
    std::thread consumer1(consumer, std::ref(queue), 1);

    producer1.join();
    consumer1.detach();

    return 0;
}
```
**Объяснение:**  
- Тип очереди:

    - Теперь очередь хранит задачи типа `std::function<void(int)>`, то есть функции, которые принимают один параметр типа int.

- Лямбда с параметром:

    - Лямбда `[id, i](int additionalParam) { ... }` принимает параметр `additionalParam`.

- Передача параметра:

    - Когда задача извлекается из очереди, мы вызываем её с параметром: `task(42)`.

## Использование std::bind для передачи параметров
Если мы не хотим менять тип очереди, но всё же хотим передать параметры в лямбду, можно использовать `std::bind`. Этот подход позволяет "зафиксировать" параметры для лямбды, чтобы она соответствовала типу `std::function<void()>`.

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <functional>
#include <mutex>
#include <condition_variable>

class ThreadSafeQueue {
public:
    void push(std::function<void()> task) {
        std::unique_lock<std::mutex> lock(mutex_);
        queue_.push(task);
        lock.unlock();
        condition_.notify_one();
    }

    std::function<void()> pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this]() { return !queue_.empty(); });
        auto task = queue_.front();
        queue_.pop();
        return task;
    }

private:
    std::queue<std::function<void()>> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;
};

void producer(ThreadSafeQueue& queue, int id) {
    for (int i = 0; i < 5; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Имитация работы
        int additionalParam = 42; // Параметр, который мы хотим передать
        queue.push(std::bind([id, i](int param) {
            std::cout << "Задача " << i << " от заказчика " << id 
                      << " с параметром " << param << " выполняется\n";
        }, additionalParam));
    }
}

void consumer(ThreadSafeQueue& queue, int id) {
    while (true) {
        auto task = queue.pop();
        task(); // Вызываем задачу (параметр уже зафиксирован)
    }
}

int main() {
    ThreadSafeQueue queue;

    std::thread producer1(producer, std::ref(queue), 1);
    std::thread consumer1(consumer, std::ref(queue), 1);

    producer1.join();
    consumer1.detach();

    return 0;
}
```
**Объяснение:**  
- `std::bind`:

    - `std::bind` фиксирует параметр additionalParam для лямбды, создавая объект типа `std::function<void()>`.

- Лямбда с параметром:

    - Лямбда `[id, i](int param) { ... }` принимает параметр param.

- Фиксация параметра:

    `std::bind([id, i](int param) { ... }, additionalParam)` создает объект, который при вызове `task()` передает additionalParam в лямбду.